#!/usr/bin/python3
import sys

def parse_macros():
    print("parsing macros...")

    with open('designs/cmdfile.txt', 'r') as cmdfile:
        macro_defs = dict()
        for file in cmdfile:
            with open(f'designs/{file.strip()}', 'r') as file:
                # only take macros
                for macro in [line.split()[1:] for line in file if '`define' in line[:7] ]:
                    # only take instruction codes
                    if macro[0][0:6] == "INSTR_" or macro[0] == "SP_START_ADDR":
                        macro_defs[macro[0]] = macro[1]

        print(macro_defs)
        return macro_defs

BASES = { "h": 16, "d": 10, "b": 2}
def bytes_for_num(num_str):
    [bits, rest] = num_str.split("'")
    (base, num) = (rest[0], rest[1:])

    bits = int(bits)
    if bits % 8 != 0:
        raise ValueError(f"trying to write {bits} bits for the value '{num_str}' is invalid, as it must be byte divisible")
    byte_cnt = bits // 8

    val = int(num, base=BASES[base])
    print(f"({bits} bits of base {base} - {rest}: {val})")

    return val.to_bytes(byte_cnt, byteorder="little", signed=False)

def build_executable(rex_path, macros, out_path):
    with open(rex_path, 'r') as file:
        # remove comments
        lines = [line.split(';')[0].strip() for line in file]
        # remove empty lines
        lines = [line for line in lines if line]
        # replace macro lines w/ expanded version
        for i in range(0, len(lines)):
            if lines[i][1:] in macros and lines[i][0] == '`':
                # print(f"i {i} in macros!")
                lines[i] = macros[lines[i][1:]]

        print(lines)

        executable = list()
        for i in range(0, len(lines)):
            # print(f"line is {lines[i]}")
            # abstract out into function that can also be used to check collisison
            
            
            executable.extend(bytes_for_num(lines[i]))

        print(executable)
        with open(out_path, "wb") as exec_file:
            exec_file.write(bytes(executable))

# turns a readable executable file (.rex) into a dumb executable (.dex)
# for running on the dCPU

if len(sys.argv) != 3 or sys.argv[1][-4:] != ".rex" or sys.argv[2][-4:] != ".dex":
    print("usage: to_dex <input.rex> <output.dex>\n    input: a readable executable file (`.rex`)\n    output: a dumb executable file (`.dex`)")
    exit(1)

macros = parse_macros()
build_executable(sys.argv[1], macros, sys.argv[2])