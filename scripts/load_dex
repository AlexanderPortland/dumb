#!/usr/bin/python3

import sys

# builds a harness around a .dex executable so that we can simulate its execution

OVERRIDE_START = "// LOADER: OVERWITE MEMORY HERE"
OVERRIDE_END = "// LOADER: STOP"

if len(sys.argv) != 4 or sys.argv[1][-4:] != ".dex":
    print("usage: load_Dex <program.dex> <design_dir> <temp_dir>\n    program: a dumb executable file (`.dex`)\n    temp_dir: the directory to put all temporary files in")
    exit(1)

program_path = sys.argv[1]
design_dir = sys.argv[2]
temp_dir = sys.argv[3]

def program_code_str():
    program_code = list()
    with open(program_path, "rb") as program:
        program_bytes = program.read()
        assert len(program_bytes) <= 256, "only have 256 bytes of addressable memory!!"
        for i in range(0, len(program_bytes)):
            print(f"byte {i} is {program_bytes[i]}")
            program_code.append(f"memory[{i}] = 8'd{program_bytes[i]};\n")
            
    return program_code

# make new temp directory
def fork_harness():
    import os
    os.makedirs(temp_dir, exist_ok=True)

    start_lines = list()
    middle = False
    end_lines = list()
    with open("designs/harness.v", "r") as existing:
        for line in existing:
            if middle:
                if OVERRIDE_END in line:
                    end_lines = list(existing)
                    break
            else:
                # print(f"Comparing: '{OVERRIDE_START}' in '{line.strip()}'")
                if OVERRIDE_START in line:
                    middle = True
                else:
                    start_lines.append(line)

        # print(f"start is {start_lines}")
        # print(f"end is {end_lines}")

        program_code = program_code_str()
        with open(f"{temp_dir}/temp_harness.v", "w") as new_file:
            new_file.write(''.join([f"// Autogenerated harness by load_dex script for {sys.argv[1]} program\n\n"] + start_lines + program_code + end_lines))

def fork_cmdfile():
    with open(f"{design_dir}/cmdfile.txt", "r") as existing:
        with open(f"{temp_dir}/cmdfile.txt", "w") as new_file:
            new_lines = [f"{design_dir}/{line}" for line in existing if line != "harness.v\n"]
            new_file.write(''.join(new_lines + [f"{temp_dir}/temp_harness.v\n"]))

def run_fork():
    import subprocess

    # iverilog -o practice -c cmdfile.txt
    result1 = subprocess.run(["iverilog", "-o", f"{temp_dir}/out", "-c", f"{temp_dir}/cmdfile.txt"], capture_output=True, text=True)
    print(result1.stdout)
    if result1.stderr:
        print("Errors:", result1.stderr)
    
    # vvp practice
    result2 = subprocess.run(["vvp", f"{temp_dir}/out"], capture_output=True, text=True)
    print(result2.stdout)
    if result2.stderr:
        print("Errors:", result2.stderr)

def remove_temp_dir():
    import shutil
    shutil.rmtree(temp_dir)

# TODO: this approach is a little dumb, I should really be reading in the bytes to memory and take in
# a file arg from harness.v
fork_harness()
fork_cmdfile()
run_fork()
# remove_temp_dir()